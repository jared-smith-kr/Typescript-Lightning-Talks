# Talk \#1 Intro, Union, and Tuple Types

* [Recording](https://kproductivity-my.sharepoint.com/:v:/g/personal/andy_orahoske_kroger_com/EZzEaUQpRqJJuf9hLSkq-DMByPKRKgTl9URLzpb1iL4GQA) \[Starts at 23:43\]
* [Playground](https://www.typescriptlang.org/play?#code/PQKgsAUAKgngDgSwHYHMAEAzA9gJ0wVyTQEMkATNOHLDBAFwC5JJY4BTAZxJzbQCt8HOiTQcAFsXYUxWADa86E4QDdis-JzQBjUmjb0xbPLWHI0uNEiyNmEDgEd8xHmjrxe1QhVXreAXj80ACNiMkgHJxc3dlFHZ14fDTQAtBQsLDCIEGBbLSwkITQADwZROhxkdECAcmwsasg8guEYUqR8AFsgo2S0AGZIDEItOgR8kjIyAAoSy07unAAaNFa5rqMASjQAb0g0NB46fBwiIrQAahXIAF9bUOmi5ZgN21AWd1EYITYOrnjtYh0NhpCoALzYFGIXH0ih6ICsHWQahAaAAREhiB02ABaEIcCGo8w4cLlfAjY5qNFCHBko48XFQgkAOjQAEkiAikbJPt9fq53H8XGQEBgMEY2EhRoCIZAgjBLJi2KVsHg2EVMXB5GgRSssPg0BJlLxdAAlADiACF+TEANrtdZLNYLZb2hYAXRI5EgugAEgBlABq1t4dvmRhdYcdrqMHpgeoBSGqwmIWi0CDIEroalk8rgUL+RH9AcgdCwIiGSBGYyIikBrmIAGtNKbLcs2EaazJ8CgxK5DDBqi42CnewJCn0nUYOEzbKxOFoKnBhGQsJorMuy4oENPZ2WELJ1NTpctSNZDHgtLJ8wgtJYsIiMdzopVXBUtA3tVxS2hhUJKvhtzEWU2DoAB3NgJTQHx02lSFyAOYhQLQQQemQOB8FMTsFA+DgviBDoWQAGRA6ovxweV6EgMwoD9JgshyCBGivDguD9YgxT9coXzVIFyFYrjUB2W5GIgJpCg4dj-EsNgkLYjiBJQKZqhNLAFjoaoXlE-JCkICSxV6ZTVKMOgAB0NIAbjQAARE0AHkAAU0CgABBC1CIAUTQTj8AzSUOHM7FsQaESKyrcZ8hzKBG04OS2BmUpYs4ipUC2XYIH2MS5DYJlZCwRSik04TIAimAoqbDhYqmPS2E0kqypiySpl0yStmAYBzCwOAOAAQjQAA5TcPiMagcG6152oAMSgCaAE1esChbFqW5aVtWtb1pW3JtOEANnMI1krOcqB3Ks3o-RgLo5CmTTIDapzDBIDp2BwCT4PPXhtz7XgmxgEsPli3pqRfAAyHY0AAfXB7dYtKXDLu5IqIDu8DqgPetZA-Yggj1YQty4K8gTwcYV1ApBBmGUZxmhySksqKrSlIZ5Yc-LzJJ2PYDhA44a3cGhRGSFJSIU6o0GB0GqpIViWqZSHqf0gJAl2-bDuOqyblsULKaIV76AQcF6bKZKUA2BK2bS-Y7pXMp8FFVwyyBuAvuCe4EE4ZZYTJ9K0FsoI+DYEYmQzWgkDYezqGetwquWapZYqyTqmWc39igtQNFKJWDqOk7Fg5-YJU6IwsfkZU1HxHOvf2UCKizIJi8wUu2HL5PtHyWgUApWulXr2Qy4564bq9u6+ts47YeQLReHAvQCmOCESGxo0+zrLgrCQiQvwenhHG3eg2A5u6qE64yYGWKeQDyfBZDIFEx2ENISEMUJPQoQ5uf5qFWbFJu0Du0gKHoNAoE9RX2CMaO2WYDzynkCgABKFzAYEljOQe7Vh7HQAEylBmvGHQiZkwsQQCgIgwoeAjBzIAgwOMRA6EKDCc8dELbtWnLHAGKQM4qxOj-dqw1cC9WYWzFca5rB6CKNuYQ4xoi8CBqgMayCyj7m5CHOesJgypEiGQJB+wdRTDlmwWmqAqobFSrnTmdJtZ9z0D3XgSd9iKGoEhEOSF3I4BGkpQgPARxFzYN1DSfd1YiTeNAJQj1nqvQoL5awzYiAgGQITfEYUkAogkSyVk6kN7YRiLhXkpE0DVD-gnKiRBcAZmMBYYgKjvwdEBFoXsAD1521EICbcGB5TKLEuUYgMSuB8xANjRQiTDDFWen-YMO5oB+hID3MsdTqi4BFiqEZdFsi2AkWgH0CAJoIEXjUMQCARYAB80AAFZxoJj0AYHo3QnbRmMJs3gFhlGyF3jgSkUj0DVB2cFNpBoEClDWRsrZOSPmNG2pgW5vz1m3N6McrSzQOpdXBf8qSuSkDyleZ8kFZ4jC2U6hwBFkLAgABY0Hk0rFreKqyIVGiMV7V+JxihMh4OwQEUw+iFROXGfUOCJkcDLJUps2phAdFwLwFAEpC7ckefylZfprmAwUmgA51zXjgGgPgTUnBbC2VhHgK8qAnCiq4IaY0RCIQ3lgk5NVWoVmgXerqfURrywICKBCbE8hUCKEgI8kOzgfyAjKdSWks9yGKB-CKMUPBJRoCxA6DgbYmQoBZPZGAih8h0XCFgd8IFehKQAIxoIAOxMgAAzFqZDmhOaAAAcRbq0D1tRyg0xBF5lJkIUYZZS4C4EwiINB2IoCWuymyIgAApcZwyaKAIUBKCgpZIBwOcM8r4mALDtiMMmnZqBT47OqacnQcCeVYmQiHIo7ARhKI3SgLgyAWC0UgEskSXyeWZuEIEG01Q82FpLSW8tyxq3VrdMC2FNpW10GWJ2nAdAPSBCfU2OgJL4mfgDGodM9ku1TCQG0SMqVhLbiQ48sgqGINTHA3QVq7V0hdV6isvmJGWavIVZOUayrIATQsIYQmeUxV6kFIurg6GhHZidhJQ9EitgToESvIRyBw3ehRVuQSHBT0IEpFjShyjO0cF1vkZYyBvhPwARIq9eDIDOWccQGAAAeQg1ZsQ0GxNmbEsJHMCgAHwsj9GWPUeAYNZtU4vT6EiTNmcs-RxVkYXMuiETaV5EYHRuiQfe26k1pozROQAdV4FyoOyBjXCM1DeAB-b1V0WlRm2DvRosKVi+6QD4kEplaza+99BbS3forX+otAGYWFGA1gIQaCwNdrQVB0QVEOB4ZQ2hkjaCyOANwA2DgJyLDzMSJoBsq8iB1jyE9fcCgEBYjoo+srFXmuftLT+qtNbOuSxbrCu664FAPSCAAusyjp21eEL1oQfRBsQb6CNmDY2JsEam121lkAgA)
* [Stack Overflow Canonical Q&A](https://stackoverflow.com/questions/66233214/why-can-typescript-not-figure-out-the-type-in-my-code)


## Typing for fun and profit:

Types are just a shaped hole that values can either fit in or not:

square type round value == bad
square type square value == good

```typescript
const x: string = 'foo'
const y: number = 3
function add(x: number, y: number) {
  return x + y
}

add(x, y)
```

Type systems are categorized as either *nominal* "name-based" or structural "structure-based". In nominal systems types are differentiated by name: for example if you have an RGB type [number, number, number] and an HSV type [number, number, number] you can't accidentally pass an HSV to a function that takes an RGB, even though they're each just 3 numbers.

Typescript does not do this.

To illustrate, another classic nominal typing trick is to distinguish between validated and raw user input in the type system. Let's try it in TS:

```typescript
class SafeString extends String {}

const safe = new SafeString('Robert')
const unsafe = 'Robert\'); DROP TABLE Students;--'

function onlyTakesSafe(x: SafeString) {
  console.log(x)
}

onlyTakesSafe(safe)
onlyTakesSafe(unsafe) // oops! No type error!

// FTFY! -------------------------------------------------------------

const VALIDATED = Symbol()

// The ampersand here is the key
type Safe = string & { __isSafe: symbol }

// we'll talk about this later on down
function isSafeString(s: any): s is Safe {
  return typeof s === 'string' && (s as Safe).__isSafe === VALIDATED
}

function sanitize(s: string): Safe {
  // do stuff to strip the baddies, then
  Object.defineProperty(s, '__isSafe', {
    value: VALIDATED,
    enumerable: false,
    writable: false,
    configurable: false,
  })

  // NOTE: since we ensured above that s now has the requisite
  // property, we *could* just go ahead and return s as Safe,
  // and it would be a totally legit use of as.
  // NOTE2: You can't assign directly without a cast either:
  // s.__isSafe == VALIDATED // error! __isSafe does not exist on type string!
  // still need the type guard.
  if (isSafeString(s)) {
    return s
  } else {
    throw new Error('unreachable!')
  }
}
```

## Unions

That ampersand denotes an *intersection* type. Well cover those more in the next talk, but it's the type system's 'and': in order for a type to match it has to satisfy the constraints of *both* the operand types. TS also has 'or' for types:

```typescript
type HiFive = 'hi' | 5

// can either be the number five or the literal string 'hi'
const hi: HiFive = 'hi'
const five: HiFive = 5
const oops: HiFive = 'any string'
const otherOops: HiFive = 42
function(x: HiFive) {
  return x.repeat(3)
}

// you can also make it more general like type Snumber = string | number
```

## Tuples

Other languages have an dedicated Tuple type where you have a fixed-length linear data structure with different members, e.g. Python:

```python
socket = ('127.0.0.1', 8080)
```

here you have a host and a port in a 2-Tuple. In JS and TS we tend to use arrays for everything, which can cause some unexpected things in TS:

```typescript
const socket = ['127.0.0.1', 8080]
const [host, port] = socket
function isValidPort(n: number) {}
isValidPort(port) // oops! type of port is string | number!
```

For heterogeneous arrays (not all the same type) TS does not infer anything special about the position, instead it types it as `Array<union-of-all-the-types>`. So our socket above is type `Array<string | number>`, not `[string, number]`.

```typescript
// FTFY

// We can define an explicit Tuple:
type Socket = [string, number]
const s: Socket = ['127.0.0.1', 8080]
const [host2, port2] = s
isValidPort(port2) // works

// or for values known at compile time:
const sock = ['127.0.0.1', 8080] as const // note the bit at the end
const [host3, port3] = sock
isValidPort(port3)
```
