# Talk \# 7 Overloads

* [Playgound](https://www.typescriptlang.org/play?#code/PTAEHkDcFMCcBsD2BDAJgZ1AKCyUAVAC2gE9RlZpzQB3ZMgF0VEORlAFsBXeBgSwAO8Kuj4BzAHbIGXSpgBmiWKAbFQ6ZByryuEgMb9EE0Hw5DoWiQ2l8jAOlxgipcpVAAqeZQCOXaFfgSd04+dF1UOHQmRFRQAAo+YwEKBlAAI2g9ZC50KkRVOFB4ZAkxLmQxaExUZgKOUFQ+eXk4fwZAgEoHPAAJVoByTEJEGlABaERzFX9Ypg9VRIBrYMQYBBQMWiVFgC4cLB19Q2Ma5yJEsXiADx31BlgLjtuoh9LQAG8sUG-QPBpWBjQNZYAC+OEOBlsJ0QZ0IF2utwkXA4GVgTzur0un1BODwACEuKlVNJQIh5KA9IhZLkPDUqhJ+gxgjRtnYIGskGhMIkCCRxug9A8BKlFPAkKN0IgtKBYDwqnsQI5QABGNnOMjoYY8WICWCIPTQaCxHlKCLKLxSopVTCUszCK4qZgcJRUW3mK5KgBMbIAmlSKSVSRJAiw2FR3O4jNAIyY7RY2jYjOkYmQyaASFTlKs4JzYhDjioAR53NwojGMuQ0sJHeQ9JTdCKlOQxaTyRnZKSORsjepxFIZHIlQBmNkAMUQYpG8It9QAxJ6ADSFqimcyWawF0SSaSycMlnJM4IVt02KtUGh8VTF5BimNp9tZrtcpUAFjZAFErnA9KEqNYoiuxjDKMHAlGQ7agGIfAwEuBQUlKAh8MIyisJgcxyBO7BgSYEiQPqibGPemagPmUI1sgHjoOMP7yHwegrE+qC4mAADKzD-P46havAsQQTkeSMegAD8oAAOrEBIQKFBBrBYSRuiQkmxKpHS1RNC0lBWIWFyYGkyC5LESaXoMOECIS3RgAAkqBUGSbQ0D9G4NCwMgAiIW8cEACLSK6RgvFwBhKGqajeYC8ESP5gXKFkxjWIsVASPkcKlEugaWSx4CgAAHAAbAADMqJFKKBDCAkxeAvBcS5NoGiSApUyj8FoUSaAI1XKBRuQPFUrY4fVkQNP4+TwnBJDQBQS7OlYhBLqg9BLtADB6GybEsCMWzavZSrOZef5Fjy+AsUJ4IKQWoHxaF0BxOil0HKdZHndAl1xHNgIsfczz3I8ty3aRSaPc9DDoIiyKojdPl3UcD3IBdPlxCQsAgyicCTUYqhI6is30EJGMo2tsg46ASLI7Ak2JIS0CE8TmPqJkRioFToN4xwSHwL+lISAzuNoj9EN-cYANwy84CwPg6Aiz6sCE5VbwAD5E0zpOcGjhCMyTWMkGrNNalL3Nk0igJa3juQc1zCvqyEYrs-TRs86Al0fF8JjknEDB8hM5LC6L4uwJLoAALyB6A-ThNAtGSag-QdI7Py-GA2brGgoCzsqTsgqA0DwDSTTxG74xpl7YsS8ogf+8HMtiFHMc-HgCe5snnppxnWcri7ece8r00B0HIec2HiRGlXnyx7XjHJ0OTeZzSw81-HY+zi+adO5QA7GJJozPR0OJKmxWhpCm5DoPFxqxWoSjiIkN6OoheiVlSqS6ogABWmSpJFA5UCUsSUPIyBRSN7t0BsksrQVmkFoKf3ki2aw8BFhBiVMpcgb8pTQAEIgOqS40iEitAwEyURJhFQ6rTU2LBWjkE5hSYQgYFiYC4AIPYWB26gAAAqIFEMcG8l0ACCsAxCYDLgAbSmqoW2GtRH411ubGmLMDaUz1sQm28iWZWxNooqRcAAC6J0ob-Rhk9Hynprq80BJDRSAs9GXUMa9aA71EYYm+vbPm91dGw0BIYoG3NwYmP5pwCxBj4bjTsdTPGdhQkUD4bcVh7CoScJ8jwvhXjoCmLOn4txcRC4+0ltLL6ct1FK1CXYcJwMWFsMvDE+A3DeHoESdXb4OdXbuwLvcEWRdfYlx7qHcOg9o4zxHnPHMGxk6p1junKerdc6NM9s072xdu5l0GDkyuPSnZ9M7AMpO84VmgFGS3Z2Ez87kiKQIvKGi5nB06QPSOyzY7fFHus2Is4J4jObtPLZtz+mJweYvEZWyV6yDXtADecMt5giVH6LgAYBZ8AdDySokkHh6HQLNdSrQtJ-NgLFQBC0loMJ8YoRARiiZSVgMksi+K4g3HsaUdEFdSVJnxQAHnwAAPgpfIkgtx8DomYXqFmuQmXMrpcYRlLKKXZMxKAeWwSlaa05TSxZkqWG8t-AK6u9T25pgdKXc5fculXNqT8VQepRjr1AO+WAepYBxH6AAOWYOE5EbQ0LMHxQAQijpPXZ6rJmgC1T3CuQ83kykWv831nrs5tx9WQV1HTdWXMDTc8KkphB2CQGIClW9E3ouMDyqUv47AYXgDAeGmbtkvKoL0n42adWUD-qwM87ql6gvuGQGe5KQUBiWoQeIcA0TVw5sm6AhT0BdQYHEOIvacItX0B3c1lrQAADIF0ZwtXYZqGhKjR21ba+1vDHVWGdUVRA7qQU4AHakOQhUy7kv6HCD157g3oE9AHI9cQhywVlNALeBxEAEqHFvG9d6P1+C3kAA)

# Overloads

Overloads in Typescript are a way to have multiple signatures for the same function implementation. They are *frequently* misunderstood (in part because other languages do them differently). Here's how people tend to *think* overloads work:

```typescript
function doTheThing (x: string): string {
    // whatever
}

function doTheThing (x: number): string {

}
```

But that of course *doesn't* work. This has to compile down to Javascript, and if the only difference is the type then you will get an error for redeclaring the same function. The compiler *could* create multiple separate functions with different names and a another the actual exported name and conditional checks to decide sub-function to delegate to, but the Typescript team really doesn't want to be in the business of layering custom dispatching machinery on top of Javascript.

Overloads in Typescript follow some rules. Like the rules of say, React hooks they may seem arbitrary at first but after working with them you come to understand and appreciate their logic. The rules are:

1. You can only have **one** implementation body of your overload function that **must** be able to account for all of your overloaded signatures
2. Following from #1, the implementation signature **must** be compatible with **all** of your overloads
3. They should proceed in order from less complex to more complex
4. Exercise taste in how many you give, the compiler has to resolve any invocation of your function to a *specific* overload

So when should you use overloads? Whenever you have a function that does different things based on it's input. For a basic example, imagine we're wrapping the Date constructor. The Date constructor can take nothing, an ISO 8601 formatted string, or an integer timestamp, or a series of integers denoting the year, month, day, etc. So how would we write that in TS?

```typescript
function makeDate(): Date
function makeDate(dateStr: string): Date
function makeDate(ts: number): Date
function makeDate(yr: number, month: number, day?: number, hour?: number, minute?: number, second?: number, millisecond?: number): Date
function makeDate(strOrTsOrYr?: string | number, month?: number, day?: number, hour?: number, minute?: number, second?: number, millisecond?: number): Date {
  // logic
  return new Date()
}
```

## Quick digression on Refactoring

Somebody asked in the original topic about project structure and refactoring types. I will give a full talk on that at somepoint, but let's stop for a second here and clean this up:

```typescript
type PositionalDateArgs = [
    month?: number,
    day?: number,
    hour?: number,
    minute?: number,
    second?: number,
    millisecond?: number,
]

function makeDate2(): Date
function makeDate2(dateStr: string): Date
function makeDate2(ts: number): Date
function makeDate2(year: number, ...args: PositionalDateArgs): Date
function makeDate2(strOrTsOrYr?: string | number, ...args: PositionalDateArgs): Date {
    return new Date()
}
```

Much easier to read. Note that although the compiler will ensure type-safety by resolving to a *specific* overload, your implementation code will still have to figure out which one you got in the function body:

```typescript
function makeDate2(): Date
function makeDate2(dateStr: string): Date
function makeDate2(ts: number): Date
function makeDate2(...args: Parameters<PositionalDateFn>): Date
function makeDate2(strOrTsOrYr?: string | number, ...args: Parameters<PositionalDateFn>): Date {
    if (typeof strOrTsOrYr === 'undefined') {
      // overload #1
    } else if (typeof strOrTsOrYr === 'string') {
      // overload #2
    } else if (typeof args[0] === 'undefined') {
      // overload #3
    } else {
      // overload #4
    }
    return new Date()
}
```

You can mix in generics, different return types, etc:

```typescript
function foo(): never // Note you don't actually need to write this one, it's implied
function foo(x: string): string
function foo<T>(x: number, y: T): Promise<T>
function foo<T>(x?: string | number, y?: T): string | Promise<T> {
  if (typeof x === 'undefined') {
      throw new Error('No arguments to foo!')
  } else if (typeof x === 'string') {
      return x
  } else if (typeof y !== 'undefined') {
      console.log(x)
      return Promise.resolve(y)
  } else {
      return 'unreachable!'
  }
}

const res = foo()          // Error
const res1 = foo('hi')     // string
const res2 = foo(3, true)  // Promise<boolean>

foo(3)                     // Error
foo('hi', true)            // Error
```

Note that this can quickly get messy:

## Real World Example

This is code I wrote for the KAP Web codebase:

```typescript
class AnalyticsCapability implements IAnalyticsCapability {
    ...

    initialize<S extends ScenarioData, M>(metaDataHook: () => M): IAnalytics<S>
    initialize<S extends ScenarioData, M, State>(
        metaDataHook: () => M,
        stateConfig: StateConfig<S, State>,
    ): IAnalyticsWithMiddleware<S, State>
    initialize<S extends ScenarioData, M, State = unknown>(
        metaDataHook: () => M,
        stateConfig?: StateConfig<S, State>,
    ): IAnalytics<S> | IAnalyticsWithMiddleware<S, State> {
        ...
    }
}
```

This is hard to read, even if you understand the problem domain well. When using overloads, especially complex ones, please exercise good judgement about the benefits vs. the readability (read: maintenance) costs, not only in the types, but also in the implementation which will need (type-safe) conditional checks on the arguments to ensure the correct behavior.
