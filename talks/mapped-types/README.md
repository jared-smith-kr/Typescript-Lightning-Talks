# Talk \# 5: Mapped and Index Types

* [Playground](https://www.typescriptlang.org/play?#code/PTAEBsFMBcGdQJYFsAOUmQHbVAQ1NAJ4qQEAWpkAHtAE64DGc5pRJoA9gGZ6gBuucAFdSXWhyR5MnAEYArSEzw5cAKBCgUuWtAQMh4baADWkQgDpQAJUgYkMyLU5CnAcw4cAJqDEIs3gANTQm4An3FJaDJcHGhBYwB+UABBTG9XLEc9WHUwMQkIXFhY5EgkgAlHSAByeCjSDMwshgJiVmicajpGZnrQACo2SH7OHj6BYUhc0d5jTA4Ad2kOeUUcFHESHUIALlVVIdAAFTaAeS4ABU3HIgAeI9Au-3gAbwBfABpQAGlHmmeTGZuMcAHygAC8xwA2t8ALoHNqgADKZA4Bk8ACFIEi6AhMK4Icczpdrttbi88DtQMVaHjXF8ZFTMEJ7I5QJ9QNVcNUQfsNDY7A4nNAFhwCPF4Lh3KAFqRPAhYPpYLBIN4+vKuFwqpgGJB4A4RZAsAMhiMGBxsF0chpcGkBhMRGaLdArZYjhRQAEnmlYGFgqLaN4FZwmjMohwVTKLcZCCG9eQYhAEKZpgEhqFQA5onx4znaLGNVraFhoOAC5ASGk6SGWKBzZaaJZ+v0ACJomRl5sDISYLgcHQ9mKQTsfaYLCjSIQqoPSfCHesumgDb2eWAjQSwMVZ3A5+CF7Wl8uV+X4mvjmAUJz96bzHAIaC1TOQatT1WIWegRrNOvOroy+9kLwPYIBarQkOYfJgA6pALl0+wMIYyqgAAYh4oAvKooBYZoQgdnolKgMyrJOJCADMqhvPBiHwBiRgrvAqFiu8oAaLRbgwJK4DgDheEMMAGwcC6TBvgJWy6PGwKMZBYEwb+S4ABQyEUegAJT7HiLq0FwjCkAAkox6GYdhjLUri+IUeplpaTpoC6Wxfwuj6tkGcxGh2UY0Scdxok3H48DAvpHjSfOck4PJuCeAIOqqmphwAKqEly1SgAAPpyMjJWl1QMNUCLsEcuCmLAcX3A5AJxWCkIYdhBFHBZqj1sUPgeFSBVFSVSWVehBFJeyWEaGQQhkAk0lIkaXx4jJAC0AbgN41T0clGC2vA-TBkUsAIK4mC4B2rAcP0lipN4gjccC+CwEInieFgo4aGiTiygggamUImqmdovRikghWkCqmAqm6HrULgqBQGGHo+dsMkOfQTDXm5n47qQiZcM9TU-UV1JYCqVLnsWMqkNmpABL89GAiEPBHGE46JrKoDLdICqpt8YRrZKypbTte0EAdnrBMC1MymQeiAX2woeocAQUrgVI0nSDJMiyQrsmEzMaAEvVZRlYS2mqHoWmW5B0hzm3bbt4PQGKUSJto7R-WZrjwL1evpblGjycWgpsrK1QE8UCBceK4DGNWu1orEbSwCpEHTO6pB4jdVDVgERwwrCYSwKi6JPpoxbQEQ77QEI94IDmVJyFOODgMmCfSNBM39nNwtVIT0wMLa75J1IsgKEoCwAbwUOF8E77TbN3j0x3TNpNQvCDG0IwD1EeDTHMizSMPsbBJYADq-bGPA4t4LQ9CxkMdQtfshwAKI0HD0DJKfuCECcJCleTtqEFCsJdWnRFCnhI1HAMgPDgCfiRUAUI6AiC+NpcAKp4SHBRGiOaWIMRgMJHfboTAIEvzfpAW46YeCgI4OA0+vI8qkGwQ-ZC6NoBHCEGgSABCP7-Ccl-H+f8oQAAYkGIhQeiLEAA5ZWbJIQ0J6HQ2gxRGHMNYVCABjgvjy3xL-aSu8YKd1fLWFYfd1ikkLlnfsNs7Q11MGPAAUjuIoDBaQoE6DmGe48m6eEsKcJo7cLS6gcQmHA5oMDwCYbwcAgkW7SHlIqKcm1TwX0QHUD0CAbrYHvLGYctgSycCvFsGIIFMDTGPnONoVJj54mKLaXUoAeHxNrEkksqTHjoEyYU66pdQIcDzIRMRMivgAEYan1GmHUlJhd0kYGwM1JwSADC6DQHoXJ7TOlKJ6bU5JuhC5cB7EwPJNSAhUAhGCKgAQ7pgFdpuEMe8tERMgGjUMF1kDMNsmshpUtDi6WeXcI4f9jmZiEDgKencNwcGmDoqIwYfooBIGqREdS5zfV+j3YZ6zz6ImPnotYsA9hUKefUz5ZUnLvC6tVbCUJR6TQFlTWErVSVmHhJRaYGI-kylwPeXgSA8R-MgAAQlAAATTRNSFl3gABExQ3o8ABREsUy9AJpjaGEG2-yrnVBwJ4aVg8AgaUcNpXUARpiu10tUSQGwYBGJcHpaoOZsbGk3BgMFp5zHtGDDKou2qdKwC5ZZTSOq9IXFOJY04hkao0t2KZWkaiqRf3qhoXleovhgvgMGDuXE3yd0TnPM2O1i4EyGF8V29RYzT1zq+Seg84n9H7CMIZVkfWwEsOURYkA8xfB7I6hmuBIVvjiQWk+pB+hdC9sOQgIwa7spdJ4L4jNqz1EjKdApLLuIuoCSgQOkApq6AwI8U+-ZMVerdZU5CC7en3DBMSrCIaqQUuOFSqQhB6pausgehdAAmINJLghUi1m7G9Ub6UPp9ShBdpE33no-WGukN7VGuCMqBswStiI3uWdGsA5hUP5pFkfBd8AXX4H6LQHsG7hhbvELQPY-6bKHsDgAFhA1AsDUHIOO3qsAgilHwA0aqm8AA3A1C0TUZCElwOYPsHAuMsTAFBnlt5QA9hurc1UnrGpkMgOYUJrhFLmGLCQGI8lSIqRUmJjQy7V1OGDJtKA2BPVx0vCjHNoplC4hkJy-yPBh5+T8XWTuDgGZeAQGjN8k0Z2kAhVCmSu6NbFgiobQgus7QcAcXkwQoB5IBASAEGOoBNF-BNUhBNMmYkEnwGgKcWSGYcvgJmz0ABqYAU0AiWAADIwEfO4fVFAIpSG8KCigkYraIDBhkiZfQAgXE+ggQQPyAg2AAI4l2LJ4WLgQbBRcwGWBVUdnAyOHLuLFhwACyhBltqtW4QNhjlVzoTeESmDoAquReO0bENY8r1HBvWnYIdLr6IgO6NnQ43wBnYBISwkZ66NmGe0CSlVWEjUo+-Vfbh3ICzeeqqQHBKrsg5u098lkPr1TRh9COH9KNDNmEacI4N8ux+dACEIQnAx21kzfGj0xmoBOA2iyeMAQqv1Y0XKC0KrQDE15qAYs8slAPRVFAXcIuBC0gtvGZ89RaBfElfl0gNdNIblAJXJqbb6byk8GODVPCFVigeU0iZA6ejTo9GjGRkd2D5EkHOJhUBduIjwYQJr+Ioho4u5w3+hI07VAs64KI1R4TTH7I8JxPmCZfnoFxO9hwffh7IP714EAsDp-gyrDHkIQ9h4j1HjQSJrYdEfCF1Ndp037LieOUWhNPOTl6-CzACAUAGCHJ1gg9AAbi0kOipgebn6EDzWkaYxdHkXwgkAA)
* [Recording](https://kproductivity-my.sharepoint.com/:v:/r/personal/jill_karacia_kroger_com/Documents/Recordings/Meeting-20220103_195119-Meeting%20Recording.mp4?csf=1&web=1&e=mS8qum) \[talk starts at 5:33\]

So waaay back in talk #2 I mentioned that when defining types `interface`s were *usually* preferrable to `type`s and went over some reasons why, including some things that `interface`s can do that `type`s can't (like use the `this` keyword).

Now it's time to talk about when to prefer `type`s.

Just like there are some things you can only do with `interface`s there are some things you can only do with `type`s. One of those things is the use of mapped types. These will let us implement a number of the built-in utility types we talked last time for ourselves.

But first lets implement a type the extracts the type of a value from an object at a particular key. Remember our good friend `keyof` from that talk? And generics from last time? Here's the generic type that extracts the *type* of the value of a known object property:

```typescript
type TypeOfProperty<T extends {}, K extends keyof T> = T[K]
type ShouldBeString = TypeOfProperty<{ a: string, b: number }, 'a'> // string
```

## A Brief Digression on the Meaning of `extends`

Remember two talks ago we discussed the differences between *type* contexts and *value* contexts. The `extends` keyword is one of those wonky ones that like `typeof` behaves very differently depending on the context. **Doubly** *unfortunately*, when used in a type context *extends* also behaves differently depending on whether or not it's being used in a generic context with a union type.

```typescript
// value context
class Foo {
    public a: number = 3
}

class Bar extends Foo {} // Bar gets all public/protected properties of Foo

// type context (basic, i.e. should make sense)
interface IFoo {
    b: string
}

interface IBar extends IFoo {} // IBar has all properties of IFoo

// type context (advanced)
type U = 'a' | 'b' | 'c'
type TakesU<T extends U> = {
    a: T
}

const foo: TakesU<'a'> = { a: 'a' } // huh?
```

See, in type-world 'extends' means *is assignable to*. And all of a sudden, our weird stuff starts to make sense. The example of the property type extractor I gave at first makes sense: where we have `K extends keyof T` what we mean is `K` *is assignable to* `keyof T` which for the type `{ a: string, b: number }` is `'a' | 'b'` and the only things assignable to that are the strings 'a' and 'b' (remember we're still talking about types). 

## Indexing Types

The indexing `T[K]` should be pretty intuitive: just like in value-world where we can index an object with a property key in type-world we can index a *type* with a known property key. Works for array types too:

```typescript
type ExtractArrayType<T extends any[]> = T[number]
const boolArr = [true, false]
type ShouldBeBool = ExtractArrayType<typeof boolArr>

type ExtractFirstTupleType<T extends any[]> = T[0]
type ShouldBeNumber = ExtractFirstTupleType<[number, string]>
```

## Mapped Types

We can use the object property shorthand like in Javascript...

```javascript
const key = 'a'
const obj = {
    [key]: 3
}
```

...even in type-world! One concept that comes up a lot when discussing types is the identity element or operation for a type: for instance 0 is the identity element for addition over numbers, 1 is the identity element for multiplication over numbers, the identity function is `x => x`, and so on. We can define a simple Identity type `type Identity<T> = T`, but we can also use this mapped type idea to make an identity type for objects:

```typescript
type Identity<T extends {}> = {
    [key in keyof T]: T[key]
}
```

This should be pretty straightforward: for an object type `T` and all `key` types in the union `keyof T` map `key` to `T[key]`.

## Index Signature Types

But wait a minute! You said "stuff we can do with `type` that we can't do with `interface`" and I'm pretty sure I've seen something like this with interfaces!

```typescript
interface IPOJO {
    [key: string]: any
}
```

Yes, this is called an [index signature type](http://www.typescriptlang.org/docs/handbook/interfaces.html#indexable-types), and they can be used with types *or* interfaces. However, unlike mapped types they are *extremely* limited:

* The key type must be `string` or `number`. You can't use it with a narrower context like a union of literals or `keyof T` or anything like that.
* The set of properties is therefor unknown, and this can *break type safety*
* Values must all be of the same type.

Meaning these all fail with compile-time errors:

```typescript
interface Fail1<T> {
    [key: keyof T]: any // key in keyof T also fails
}

interface Fail2 {
    [key: 'a' | 'b']: any
}

interface Fail3 {
    [key: string]: string
    [key: number]: number
}
```

...and this fails with a *runtime* error:

```typescript
interface Fail4 {
    [key: string]: string
}

const a: Fail4 = {};
const b = a.foo; // string! not undefined!
console.log(b.repeat(3)) // compiler is silent!
```

I'm not saying index signature types are *bad*, they have their place, but be aware of the caveats. By contrast, mapped types can *only* be used with the `type` keyword, and unlike index signature types they describe a complete (not open-ended) shape for an object type: `type Succeeds1<T> = { [key: keyof T]: any }` will *only* have the keys of type `T` as object properties as far as the compiler is concerned.

Also be aware that neither mapped types nor index signature types support named properties. If you want to have some specific properties in addition to the mapped or index signature catch-all use intersection types:

```typescript
type SomeMappedStringAndANumber<T> = {
    [key in keyof T]: string
} & { a: number }
```

## Property Attribute Modifiers

There are two attributes of properties that can be modified in these mapped types, `readonly` and optional (`?`). We express this using a plus or minus sign `+/-`. Let's go ahead and use these to implement the `Partial`, `Required` and `Readonly` types ourselves:

```typescript
type MyReadonly<T extends {}> = {
    +readonly [key in keyof T]: T[key]
}

type MyPartial<T extends {}> = {
    [key in keyof T]+?: T[key]
}

type MyRequired<T extends {}> = {
    [key in keyof T]-?: T[key]
}
```

**NOTE** if you omit the sign, the compiler assumes `+`.

### Exercise for the Reader

Implement type `Writable` that makes all `readonly` properties of a type writable.

We don't have to restrict ourseleves to variables either, we can use literals just like we did with `0` to implement extracting the first type from a tuple:

```typescript
type ArrayLength<T extends any[]> = T['length']

// or even more generally
type Length<T extends { length: number }> = T['length']
```

So that's mapped and index types which we can use to manipulate and transform object, array, and tuple types.

## Putting it to Bed

So now we can fully answer the question that got asked waaaay back when about interfaces vs types. Lets summarize:

### Advantages of Interfaces over Types (see notes for talk #2):

* Can use a properly polymorphic `this` keyword as a type, e.g. the return value of a method in a fluent interface
* Open to extension: you can monkey-patch existing or built-in or 3rd party interfaces, e.g. [extending window to declare a global](https://mariusschulz.com/blog/declaring-global-variables-in-typescript#augmenting-the-window-interface)
* Better error warnings about property name conflicts in intersection types
* For TS < 4.2 unlike types they are not silently inlined (which leads to large bloat in .d.ts files)

### Advantages of Types over Interfaces:

* Can be used to create mapped types, most (all?) utility types **cannot** be implemented with interfaces
* ...which follows then that any time you need to *manipulate* another *type*, you want to use `type` not `interface`
* Can be used to declare things that are not object types, like a union of primitive literals.

If you're more into visuals then [this graphic](https://github.com/typescript-cheatsheets/react#useful-table-for-types-vs-interfaces) has you covered. So if your use-case doesn't involve anything related to the differences above, it probably doesn't matter. There you go.
