# Talk \# 6 Overloads

* [Playgound](https://www.typescriptlang.org/play?#code/PTAEHkDcFMCcBsD2BDAJgZ1AKCyUAVAC2gE9RlZpzQB3ZMgF0VEORlAFsBXeBgSwAO8Kuj4BzAHbIGXSpgBmiWKAbFQ6ZByryuEgMb9EE0Hw5DoWiQ2l8jAOlxgipcpVAAqeZQCOXaFfgSd04+dF1UOHQmRFRQAAo+YwEKBlAAI2g9ZC50KkRVOFB4ZAkxLmQxaExUZgKOUFQ+eXk4fwZAgEoHPAAJVoByTEJEGlABaERzFX9Ypg9VRIBrYMQYBBQMWiVFgC4cLB19Q2Ma5yJEsXiADx31BlgLjtuoh9LQAG8sUG-QPBpWBjQNZYAC+OEOBlsJ0QZ0IF2utwkXA4GVgTzur0un1BODwACEuKlVNJQIh5KA9IhZLkPDUqhJ+gxgjRtnYIGskGhMIkCCRxug9A8BKlFPAkKN0IgtKBYDwqnsQI5QABGNnOMjoYY8WICWCIPTQaCxHlKCLKLxSopVTCUszCK4qZgcJRUW3mK5KgBMbIAmlSKSVSRJAiw2FR3O4jNAIyY7RY2jYjOkYmQyaASFTlKs4JzYhDjioAR53NwojGMuQ0sJHeQ9JTdCKlOQxaTyRnZKSORsjepxFIZHIlQBmNkAMUQYpG8It9QAxJ6ADSFqimcyWawF0SSaSycMlnJM4IVt02KtUGh8VTF5BimNp9tZrtcpUAFjZAFErnA9KEqNYoiuxjDKMHAlGQ7agGIfAwEuBQUlKAh8MIyisJgcxyBO7BgSYEiQPqibGPemagPmUI1sgHjoOMP7yHwegrE+qC4mAADKzD-P46havAsQQTkeSMegAD8oAAOrEBIQKFBBrBYSRuiQkmxKpHS1RNC0lBWIWFyYGkyC5LESaXoMOECIS3RgAAkqBUGSbQ0D9G4NCwMgAiIW8cEACLSK6RgvFwBhKGqajeYC8ESP5gXKFkxjWIsVASPkcKlEugaWSx4CgAAHAAbAADMqJFKKBDCAkxeAvBcS5NoGiSApUyj8FoUSaAI1XKBRuQPFUrY4fVkQNP4+TwnBJDQBQS7OlYhBLqg9BLtADB6GybEsCMWzavZSrOZef5Fjy+AsUJ4IKQWoHxaF0BxOil0HKdZHndAl1xHNgIsfczz3I8ty3aRSaPc9DDoIiyKojdPl3UcD3IBdPlxCQsAgyicCTUYqhI6is30EJGMo2tsg46ASLI7Ak2JIS0CE8TmPqJkRioFToN4xwSHwL+lISAzuNoj9EN-cYANwy84CwPg6Aiz6sCE5VbwAD5E0zpOcGjhCMyTWMkGrNNalL3Nk0igJa3juQc1zCvqyEYrs-TRs86Al0fF8JjknEDB8hM5LC6L4uwJLoAALyB6A-ThNAtGSag-QdI7Py-GA2brGgoCzsqTsgqA0DwDSTTxG74xpl7YsS8ogf+8HMtiFHMc-HgCe5snnppxnWcri7ece8r00B0HIec2HiRGlXnyx7XjHJ0OTeZzSw81-HY+zi+adO5QA7GJJozPR0OJKmxWhpCm5DoPFxqxWoSjiIkN6OoheiVlSqS6ogABWmSpJFA5UCUsSUPIyBRSN7t0BsksrQVmkFoKf3ki2aw8BFhBiVMpcgb8pTQAEIgOqS40iEitAwEyURJhFQ6rTU2LBWjkE5hSYQgYFiYC4AIPYWB26gAAAqIFEMcG8l0ACCsAxCYDLgAbSmqoW2GtRH411ubGmLMDaUz1sQm28iWZWxNooqRcAAC6J0ob-Rhk9Hynprq80BJDRSAs9GXUMa9aA71EYYm+vbPm91dGw0BIYoG3NwYmP5pwCxBj4bjTsdTPGdhQkUD4bcVh7CoScJ8jwvhXjoCmLOn4txcRC4+0ltLL6ct1FK1CXYcJwMWFsMvDE+A3DeHoESdXb4OdXbuwLvcEWRdfYlx7qHcOg9o4zxHnPHMGxk6p1junKerdc6NM9s072xdu5l0GDkyuPSnZ9M7AMpO84VmgFGS3Z2Ez87kiKQIvKGi5nB06QPSOyzY7fFHus2Is4J4jObtPLZtz+mJweYvEZWyV6yDXtADecMt5giVH6LgAYBZ8AdDySokkHh6HQLNdSrQtJ-NgLFQBC0loMJ8YoRARiiZSVgMksi+K4g3HsaUdEFdSVJnxQAHnwAAPgpfIkgtx8DomYXqFmuQmXMrpcYRlLKKXZMxKAeWwSlaa05TSxZkqWG8t-AK6u9T25pgdKXc5fculXNqT8VQepRjr1AO+WAepYBxH6AAOWYOE5EbQ0LMHxQAQijpPXZ6rJmgC1T3CuQ83kykWv831nrs5tx9WQV1HTdWXMDTc8KkphB2CQGIClW9E3ouMDyqUv47AYXgDAeGmbtkvKoL0n42adWUD-qwM87ql6gvuGQGe5KQUBiWoQeIcA0TVw5sm6AhT0BdQYHEOIvacItX0B3c1lrQAADIF0ZwtXYZqGhKjR21ba+1vDHVWGdUVRA7qQU4AHakOQhUy7kv6HCD157g3oE9AHI9cQhywVlNALeBxEAEqHFvG9d6P1+C3kAA)

# Overloads

Overloads in Typescript are a way to have multiple signatures for the same function implementation. They are *frequently* misunderstood (in part because other languages do them differently). Here's how people tend to *think* overloads work:

```typescript
function doTheThing (x: string): string {
    // whatever
}

function doTheThing (x: number): string {

}
```

But that of course *doesn't* work. Overloads in Typescript follow some rules:

1. They should proceed in order from less complex to more complex
2. You can only have **one** implementation body of your overload function that **must** be able to account for all of your overloaded signatures
3. Following from #2, the implementation signature **must** be compatible with **all** of your overloads
4. Exercise taste in how many you give, the compiler has to resolve any invocation of your function to a *specific* overload

So when should you use overloads? Whenever you have a function that does different things based on it's input. Imagine we're wrapping the Date constructor. The Date constructor can take nothing, an ISO 8601 formatted string, or an integer timestamp, or a series of integers denoting the year, month, day, etc. So how would we write that in TS?

```typescript
function makeDate(): Date
function makeDate(dateStr: string): Date
function makeDate(ts: number): Date
function makeDate(yr: number, month: number, day?: number, hour?: number, minute?: number, second?: number, millisecond?: number): Date
function makeDate(strOrTsOrYr?: string | number, month?: number, day?: number, hour?: number, minute?: number, second?: number, millisecond?: number): Date {
  // logic
  return new Date()
}
```

## Quick digression on Refactoring

Somebody asked in the original topic about project structure and refactoring types. I will give a full talk on that at somepoint, but let's stop for a second here and clean this up:

```typescript
type PositionalDateArgs = [
    month?: number,
    day?: number,
    hour?: number,
    minute?: number,
    second?: number,
    millisecond?: number,
]

function makeDate2(): Date
function makeDate2(dateStr: string): Date
function makeDate2(ts: number): Date
function makeDate2(year: number, ...args: PositionalDateArgs): Date
function makeDate2(strOrTsOrYr?: string | number, ...args: PositionalDateArgs): Date {
    return new Date()
}
```

Note that although the compiler will ensure type-safety by resolving to a *specific* overload, your code will still have to figure out which one you got in the function body:

```typescript
function makeDate2(): Date
function makeDate2(dateStr: string): Date
function makeDate2(ts: number): Date
function makeDate2(...args: Parameters<PositionalDateFn>): Date
function makeDate2(strOrTsOrYr?: string | number, ...args: Parameters<PositionalDateFn>): Date {
    if (typeof strOrTsOrYr === 'undefined') {
      // overload #1
    } else if (typeof strOrTsOrYr === 'string') {
      // overload #2
    } else if (typeof args[0] === 'undefined') {
      // overload #3
    } else {
      // overload #4
    }
    return new Date()
}
```

You can mix in generics, different return types, etc:

```typescript
function foo(): never
function foo(x: string): string
function foo<T>(x: number, y: T): Promise<T>
function foo<T>(x?: string | number, y?: T): string | Promise<T> {
  if (typeof x === 'undefined') {
      throw new Error('No arguments to foo!')
  } else if (typeof x === 'string') {
      return x
  } else if (typeof y !== 'undefined') {
      console.log(x)
      return Promise.resolve(y)
  } else {
      return 'unreachable!'
  }
}

try {
  foo()
} catch (err) {
  console.assert((err instanceof Error && err.message) === 'No arguments to foo!')
}

const res1 = foo('hi')     // string
const res2 = foo(3, true)  // Promise<boolean>

foo(3)                     // Error
foo('hi', true)            // Error
```
